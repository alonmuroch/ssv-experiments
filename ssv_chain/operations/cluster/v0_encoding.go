// Code generated by fastssz. DO NOT EDIT.
// Hash: 904336848a38c1462c5103e42ac94fa68d16ad75b1a729fe35257d6b47888b6d
// Version: 0.1.2
package cluster

import (
	ssz "github.com/ferranbt/fastssz"
	"ssv-experiments/ssv_chain/types"
)

// MarshalSSZ ssz marshals the addClusterV0 object
func (a *addClusterV0) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the addClusterV0 object to a target array
func (a *addClusterV0) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(24)

	// Field (0) 'ModuleID'
	dst = ssz.MarshalUint64(dst, a.ModuleID)

	// Offset (1) 'Operators'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(a.Operators) * 8

	// Field (2) 'FaultyNodes'
	dst = ssz.MarshalUint64(dst, a.FaultyNodes)

	// Offset (3) 'Instances'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(a.Instances); ii++ {
		offset += 4
		offset += a.Instances[ii].SizeSSZ()
	}

	// Field (1) 'Operators'
	if size := len(a.Operators); size > 13 {
		err = ssz.ErrListTooBigFn("addClusterV0.Operators", size, 13)
		return
	}
	for ii := 0; ii < len(a.Operators); ii++ {
		dst = ssz.MarshalUint64(dst, a.Operators[ii])
	}

	// Field (3) 'Instances'
	if size := len(a.Instances); size > 500 {
		err = ssz.ErrListTooBigFn("addClusterV0.Instances", size, 500)
		return
	}
	{
		offset = 4 * len(a.Instances)
		for ii := 0; ii < len(a.Instances); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += a.Instances[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(a.Instances); ii++ {
		if dst, err = a.Instances[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the addClusterV0 object
func (a *addClusterV0) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 24 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o3 uint64

	// Field (0) 'ModuleID'
	a.ModuleID = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'Operators'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 24 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'FaultyNodes'
	a.FaultyNodes = ssz.UnmarshallUint64(buf[12:20])

	// Offset (3) 'Instances'
	if o3 = ssz.ReadOffset(buf[20:24]); o3 > size || o1 > o3 {
		return ssz.ErrOffset
	}

	// Field (1) 'Operators'
	{
		buf = tail[o1:o3]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		a.Operators = ssz.ExtendUint64(a.Operators, num)
		for ii := 0; ii < num; ii++ {
			a.Operators[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}

	// Field (3) 'Instances'
	{
		buf = tail[o3:]
		num, err := ssz.DecodeDynamicLength(buf, 500)
		if err != nil {
			return err
		}
		a.Instances = make([]*types.ClusterInstance, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if a.Instances[indx] == nil {
				a.Instances[indx] = new(types.ClusterInstance)
			}
			if err = a.Instances[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the addClusterV0 object
func (a *addClusterV0) SizeSSZ() (size int) {
	size = 24

	// Field (1) 'Operators'
	size += len(a.Operators) * 8

	// Field (3) 'Instances'
	for ii := 0; ii < len(a.Instances); ii++ {
		size += 4
		size += a.Instances[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the addClusterV0 object
func (a *addClusterV0) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the addClusterV0 object with a hasher
func (a *addClusterV0) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ModuleID'
	hh.PutUint64(a.ModuleID)

	// Field (1) 'Operators'
	{
		if size := len(a.Operators); size > 13 {
			err = ssz.ErrListTooBigFn("addClusterV0.Operators", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range a.Operators {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(a.Operators))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (2) 'FaultyNodes'
	hh.PutUint64(a.FaultyNodes)

	// Field (3) 'Instances'
	{
		subIndx := hh.Index()
		num := uint64(len(a.Instances))
		if num > 500 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range a.Instances {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 500)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the addClusterV0 object
func (a *addClusterV0) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the modifyClusterV0 object
func (m *modifyClusterV0) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the modifyClusterV0 object to a target array
func (m *modifyClusterV0) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(16)

	// Field (0) 'ClusterID'
	dst = ssz.MarshalUint64(dst, m.ClusterID)

	// Offset (1) 'InstancesToAdd'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(m.InstancesToAdd); ii++ {
		offset += 4
		offset += m.InstancesToAdd[ii].SizeSSZ()
	}

	// Offset (2) 'InstancesToRemove'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(m.InstancesToRemove); ii++ {
		offset += 4
		offset += m.InstancesToRemove[ii].SizeSSZ()
	}

	// Field (1) 'InstancesToAdd'
	if size := len(m.InstancesToAdd); size > 500 {
		err = ssz.ErrListTooBigFn("modifyClusterV0.InstancesToAdd", size, 500)
		return
	}
	{
		offset = 4 * len(m.InstancesToAdd)
		for ii := 0; ii < len(m.InstancesToAdd); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += m.InstancesToAdd[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(m.InstancesToAdd); ii++ {
		if dst, err = m.InstancesToAdd[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'InstancesToRemove'
	if size := len(m.InstancesToRemove); size > 500 {
		err = ssz.ErrListTooBigFn("modifyClusterV0.InstancesToRemove", size, 500)
		return
	}
	{
		offset = 4 * len(m.InstancesToRemove)
		for ii := 0; ii < len(m.InstancesToRemove); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += m.InstancesToRemove[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(m.InstancesToRemove); ii++ {
		if dst, err = m.InstancesToRemove[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the modifyClusterV0 object
func (m *modifyClusterV0) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 16 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2 uint64

	// Field (0) 'ClusterID'
	m.ClusterID = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'InstancesToAdd'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 16 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'InstancesToRemove'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Field (1) 'InstancesToAdd'
	{
		buf = tail[o1:o2]
		num, err := ssz.DecodeDynamicLength(buf, 500)
		if err != nil {
			return err
		}
		m.InstancesToAdd = make([]*types.ClusterInstance, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if m.InstancesToAdd[indx] == nil {
				m.InstancesToAdd[indx] = new(types.ClusterInstance)
			}
			if err = m.InstancesToAdd[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (2) 'InstancesToRemove'
	{
		buf = tail[o2:]
		num, err := ssz.DecodeDynamicLength(buf, 500)
		if err != nil {
			return err
		}
		m.InstancesToRemove = make([]*types.ClusterInstance, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if m.InstancesToRemove[indx] == nil {
				m.InstancesToRemove[indx] = new(types.ClusterInstance)
			}
			if err = m.InstancesToRemove[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the modifyClusterV0 object
func (m *modifyClusterV0) SizeSSZ() (size int) {
	size = 16

	// Field (1) 'InstancesToAdd'
	for ii := 0; ii < len(m.InstancesToAdd); ii++ {
		size += 4
		size += m.InstancesToAdd[ii].SizeSSZ()
	}

	// Field (2) 'InstancesToRemove'
	for ii := 0; ii < len(m.InstancesToRemove); ii++ {
		size += 4
		size += m.InstancesToRemove[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the modifyClusterV0 object
func (m *modifyClusterV0) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the modifyClusterV0 object with a hasher
func (m *modifyClusterV0) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ClusterID'
	hh.PutUint64(m.ClusterID)

	// Field (1) 'InstancesToAdd'
	{
		subIndx := hh.Index()
		num := uint64(len(m.InstancesToAdd))
		if num > 500 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range m.InstancesToAdd {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 500)
	}

	// Field (2) 'InstancesToRemove'
	{
		subIndx := hh.Index()
		num := uint64(len(m.InstancesToRemove))
		if num > 500 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range m.InstancesToRemove {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 500)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the modifyClusterV0 object
func (m *modifyClusterV0) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}
