// Code generated by fastssz. DO NOT EDIT.
// Hash: ff84c782ff437366a7801a47ec49802b321e4883a75c5ae0f8366c3ea0744f60
// Version: 0.1.2
package types

import (
	ssz "github.com/ferranbt/fastssz"
	"ssv-experiments/ssv_chain/common"
)

// MarshalSSZ ssz marshals the Validator object
func (v *Validator) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the Validator object to a target array
func (v *Validator) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(26)

	// Field (0) 'ID'
	dst = ssz.MarshalUint64(dst, v.ID)

	// Field (1) 'Active'
	dst = ssz.MarshalBool(dst, v.Active)

	// Field (2) 'Slashed'
	dst = ssz.MarshalBool(dst, v.Slashed)

	// Offset (3) 'Address'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Address)

	// Field (4) 'VotingPower'
	dst = ssz.MarshalUint64(dst, v.VotingPower)

	// Offset (5) 'PublicKey'
	dst = ssz.WriteOffset(dst, offset)
	if v.PublicKey == nil {
		v.PublicKey = new(common.CryptoKey)
	}
	offset += v.PublicKey.SizeSSZ()

	// Field (3) 'Address'
	if size := len(v.Address); size > 128 {
		err = ssz.ErrBytesLengthFn("Validator.Address", size, 128)
		return
	}
	dst = append(dst, v.Address...)

	// Field (5) 'PublicKey'
	if dst, err = v.PublicKey.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Validator object
func (v *Validator) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 26 {
		return ssz.ErrSize
	}

	tail := buf
	var o3, o5 uint64

	// Field (0) 'ID'
	v.ID = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Active'
	v.Active = ssz.UnmarshalBool(buf[8:9])

	// Field (2) 'Slashed'
	v.Slashed = ssz.UnmarshalBool(buf[9:10])

	// Offset (3) 'Address'
	if o3 = ssz.ReadOffset(buf[10:14]); o3 > size {
		return ssz.ErrOffset
	}

	if o3 < 26 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'VotingPower'
	v.VotingPower = ssz.UnmarshallUint64(buf[14:22])

	// Offset (5) 'PublicKey'
	if o5 = ssz.ReadOffset(buf[22:26]); o5 > size || o3 > o5 {
		return ssz.ErrOffset
	}

	// Field (3) 'Address'
	{
		buf = tail[o3:o5]
		if len(buf) > 128 {
			return ssz.ErrBytesLength
		}
		if cap(v.Address) == 0 {
			v.Address = make([]byte, 0, len(buf))
		}
		v.Address = append(v.Address, buf...)
	}

	// Field (5) 'PublicKey'
	{
		buf = tail[o5:]
		if v.PublicKey == nil {
			v.PublicKey = new(common.CryptoKey)
		}
		if err = v.PublicKey.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Validator object
func (v *Validator) SizeSSZ() (size int) {
	size = 26

	// Field (3) 'Address'
	size += len(v.Address)

	// Field (5) 'PublicKey'
	if v.PublicKey == nil {
		v.PublicKey = new(common.CryptoKey)
	}
	size += v.PublicKey.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the Validator object
func (v *Validator) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the Validator object with a hasher
func (v *Validator) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ID'
	hh.PutUint64(v.ID)

	// Field (1) 'Active'
	hh.PutBool(v.Active)

	// Field (2) 'Slashed'
	hh.PutBool(v.Slashed)

	// Field (3) 'Address'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(v.Address))
		if byteLen > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(v.Address)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (128+31)/32)
	}

	// Field (4) 'VotingPower'
	hh.PutUint64(v.VotingPower)

	// Field (5) 'PublicKey'
	if err = v.PublicKey.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Validator object
func (v *Validator) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}
